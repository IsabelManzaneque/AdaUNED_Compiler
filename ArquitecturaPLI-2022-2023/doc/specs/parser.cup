package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	int errorCounter = 0;

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales (Ejemplo)

// DELIMITADORES
terminal Token DOUBLEQ;
terminal Token LEFTBRACKET;
terminal Token RIGHTBRACKET;
terminal Token COMMENT;
terminal Token COMMA;
terminal Token SEMICOLON;
terminal Token COLON;


// OPERADORES ARITMETICOS
terminal Token PLUS;
terminal Token MINUS;
terminal Token MULT;
terminal Token DIV;
terminal Token GREATERTHAN;
terminal Token LESSTHAN;
terminal Token NOTEQUAL;
terminal Token ASIGN;
terminal Token ACCESS;


// PALABRAS RESERVADAS
terminal Token AND;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FUNCTION;
terminal Token IF;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OUT;
terminal Token PROCEDURE;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
terminal Token WHILE;


// PATRONES
terminal Token ID;
terminal Token STRING;
terminal Token INT;

// Declaracion de no terminales. No modificar los propuestos

non terminal  			program;
non terminal Axiom		axiom;

non terminal cabecera;
non terminal cuerpo;
non terminal bloque;
non terminal declaraciones;
non terminal sentencias;

non terminal tipoConstanteSimbolica;
non terminal constanteSimbolica;
non terminal constantesSimbolicas;

non terminal opcionTipo;
non terminal tipoEstructurado;
non terminal cabaceraTipoEstructurado;
non terminal campoTipoEstructurado;
non terminal camposTipoEstructurado;
non terminal finTipoEstructurado;
non terminal tipoGlobal;
non terminal tiposGlobales;

non terminal variableSimple;
non terminal variableGlobal;
non terminal variablesGlobales;
non terminal subprogramas;


// la ultima precedencia declarada es la que mas prioridad tiene, la primera la que menos
// Declaracion de relaciones de precedencia
precedence left     AND; 
precedence left     NOTEQUAL;
precedence left     GREATERTHAN;
precedence left     MINUS;
precedence left     MULT;
precedence left     ACCESS, LEFTBRACKET, RIGHTBRACKET; // estos se supone que tienen la misma precedencia. juntos o separados?


// Declaración de reglas de produccion


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {:   		
  		if(errorCounter != 0) syntaxErrorManager.syntaxInfo ("Numero de errores: " + errorCounter);
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


// INICIO DEL PROGRAMA

axiom ::= cabecera cuerpo;

// Reglas de produccion de cabecera

cabecera ::= PROCEDURE ID LEFTBRACKET RIGHTBRACKET IS;
cabecera ::= PROCEDURE error{:syntaxErrorManager.syntaxInfo("Especifique un nombre de programa"); errorCounter ++;:} LEFTBRACKET RIGHTBRACKET IS
           | PROCEDURE ID error{:syntaxErrorManager.syntaxInfo("Se esperaba ("); errorCounter ++;:} RIGHTBRACKET IS
           | PROCEDURE ID LEFTBRACKET error{:syntaxErrorManager.syntaxInfo("Se esperaba )"); errorCounter ++;:} IS
           | PROCEDURE ID LEFTBRACKET RIGHTBRACKET error{:syntaxErrorManager.syntaxInfo("Se esperaba IS"); errorCounter ++;:};
   
           
// Reglas de produccion del cuerpo
 
 cuerpo ::= declaraciones BEGIN sentencias END ID SEMICOLON
 		  | BEGIN sentencias END ID SEMICOLON
 		  | declaraciones BEGIN END ID SEMICOLON
 		  | BEGIN END ID SEMICOLON;
 cuerpo ::= declaraciones BEGIN sentencias error{:syntaxErrorManager.syntaxInfo("Se esperaba END"); errorCounter ++;:} ID SEMICOLON
          | declaraciones BEGIN sentencias END error{:syntaxErrorManager.syntaxInfo("Se esperaba un identificador"); errorCounter ++;:} SEMICOLON
          | declaraciones BEGIN sentencias END ID error{:syntaxErrorManager.syntaxInfo("Se esperaba ;"); errorCounter ++;:};
          
 
 
 // Reglas de produccion de las declaraciones

 declaraciones ::= constantesSimbolicas tiposGlobales variablesGlobales subprogramas 
 				 | constantesSimbolicas variablesGlobales subprogramas 
 				 | constantesSimbolicas tiposGlobales subprogramas
 				 | constantesSimbolicas tiposGlobales variablesGlobales
                 | constantesSimbolicas tiposGlobales
           		 | constantesSimbolicas variablesGlobales
           		 | constantesSimbolicas subprogramas
           		 | tiposGlobales variablesGlobales
           		 | tiposGlobales subprogramas
           		 | variablesGlobales subprogramas
           		 | constantesSimbolicas 
           		 | tiposGlobales 
           		 | variablesGlobales
           		 | subprogramas;
           	
 // Reglas de produccion de las constantes simbolicas
 
 constantesSimbolicas ::= constantesSimbolicas constanteSimbolica | constanteSimbolica;
 
 tipoConstanteSimbolica ::= TRUE | FALSE | INTEGER;
 
 constanteSimbolica ::= ID COLON CONSTANT ASIGN tipoConstanteSimbolica SEMICOLON
                      | ID COLON CONSTANT ASIGN tipoConstanteSimbolica {:syntaxErrorManager.syntaxInfo("Se esperaba ;"); errorCounter ++;:}
                      | ID COLON CONSTANT ASIGN {:syntaxErrorManager.syntaxInfo("Se esperaba un valor entero / logico"); errorCounter ++;:} SEMICOLON
                      | ID COLON {:syntaxErrorManager.syntaxInfo("falta palabra reservada constant"); errorCounter ++;:} tipoConstanteSimbolica SEMICOLON
                      | ID {:syntaxErrorManager.syntaxInfo("Se esperaba :"); errorCounter ++;:} CONSTANT ASIGN tipoConstanteSimbolica SEMICOLON
                      | {:syntaxErrorManager.syntaxInfo("Se esperaba un identificador"); errorCounter ++;:} COLON CONSTANT ASIGN tipoConstanteSimbolica SEMICOLON;
                      
                      
  	       
 // Reglas de produccion de los tipos globales
 
 variableSimple ::= ID COLON INTEGER SEMICOLON | ID COLON BOOLEAN SEMICOLON | ID COLON ID SEMICOLON;
 
 tiposGlobales ::= tiposGlobales tipoGlobal | tipoGlobal;
 
 tipoGlobal ::= TYPE ID IS RECORD camposTipoEstructurado END RECORD SEMICOLON;
 
 camposTipoEstructurado ::= camposTipoEstructurado variableSimple | variableSimple;
 
  
  
 // Reglas de produccion de variables
 
 variablesGlobales ::= variablesGlobales variableGlobal | variableGlobal;
 
 
 
 
 

